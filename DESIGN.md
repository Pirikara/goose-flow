# Claude Codeのタスク分割機構とGoose-flowへの応用設計
## Claude CodeにおけるTaskツールとチェックリストの仕組み

Claude Codeでは、大きなタスクを自動で細分化し、\*\*サブタスクごとに個別のエージェント（子アシスタント）\*\*を起動する仕組みが導入されています。具体的には「**Task**」という専用ツールを使い、メインのアシスタント（親）が一部の作業を子アシスタントに委譲します。子アシスタントは親とは独立したコンテキスト（会話履歴）で動作し、**タスク完了後に結果の要約だけを親に返す**のが特徴です。これにより、親は自分で詳細な処理を全て追わずに済み、**長大な履歴を引きずらずに**必要な情報だけ受け取れるため、トークン消費やコンテキスト制限の面で非常に効率的です。

このTaskツールは内部で**MCP（Model Context Protocol）**を利用して実現されています。Claude Code自身がMCPサーバーとして振る舞い、親アシスタントから子タスクのリクエストを受け取る形になっています。親はTaskツールを呼び出すときにサブタスクの説明やプロンプトを渡し、Claude Codeは裏側でその内容を別セッションとして実行します。子のセッションではさらにTaskツールを呼ぶこと（再帰的なタスク分割）は禁止され、階層は**親子関係の1段階**に留められます。親タスクは子タスクが完了するまで待機（実質的に一時停止）し、子から返ってきた結果を受け取って処理を再開します。このように**親子の制御**はMCP経由のツール呼び出しによって半自動的に管理され、親が子の完了を検知して進む流れになっています。

さらに、Claude Codeでは**チェックリスト（ToDoリスト）**を活用してタスクを体系的に進める工夫もあります。モデルに対し「TodoWrite」「TodoRead」というツールを頻繁に使うよう指示し、複雑なタスクでは最初に**やるべきステップの一覧（ToDoリスト）を作成**させます。これによりモデルは計画を立てながら作業し、進捗をユーザーに見せることができます。実際、Anthropicの提示するベストプラクティスでも「大きな課題ではMarkdownのToDoリストを使ってタスクを整理すると効果的」とされています。Claude CodeのOrchestrator用プロンプト（mizchi氏の例）でも、**各ステップとサブタスクをTodoWriteで記録し、ユーザーに進捗を見せる**よう推奨していました。このチェックリストにより、モデルは自分の計画を常に参照・更新でき、複数工程にわたる作業でも抜け漏れなく進められます。

なお、Claude Code版オーケストレーターの特徴として**並列実行**への対応も挙げられます。Roo Codeではサブタスクを順番に実行していましたが（並列非対応）、Claude CodeのTaskツールは**1つのステップ内で複数の子タスクを並行して走らせることが可能**です。実際のプロンプト手法としては、「Step 2ではAとBのタスクを並行実行し、両方完了してから次に進む」とモデルに指示し、Claude Codeが裏でそれぞれのTaskツール呼び出しを行って完了を待ち合わせます。並列化した各子タスクの出力結果は、最後に親アシスタント側で**統合・要約**されます。Claude Code内部コードの解析によれば、複数エージェントの結果を統合するためのシステムプロンプトも用意されており、子たちの知見を矛盾なくまとめて包括的な解答を構成するよう指示されています。こうした並列タスク＋結果統合の流れにより、大規模なタスクでも効率良く高速に処理できるわけです。

## Gooseを用いた親子オーケストレーションとMCP活用

ご質問では「親オーケストレーターもGooseとして動作させる」とのことでしたので、**Gooseエージェント自体を親役としてサブタスク管理を行う**前提で設計を考えます。にある通り、Gooseはもともと任意のLLMを使ってコードの実行・編集からテスト、さらには**ワークフローのオーケストレーション**まで自律的に行えるローカルエージェントです。GooseはMCPを介した外部ツール連携を強みとしており、SlackやGitHub、ブラウザ操作など様々な\*\*MCPサーバー（拡張機能）\*\*をプラグインとして利用できます。したがって、タスク分割や他のエージェント呼び出しといった高度な操作も、MCP拡張の形で組み込めばGooseから実行可能です。

**Goose自身がMCPサーバーとして動作する機能**も備わっています。例えばGoose DesktopやCLIは、外部から接続すればMCPクライアント（ClaudeやCursorなど）に対してGooseのツール類を提供するサーバーになりえます。ただ今回目指すのは「Goose内で自己完結的に親子エージェントを動かす」ことですから、Goose内で**親エージェントが子エージェントを起動・制御する**仕組みを構築することになります。そのためにMCPの考え方を応用し、Gooseに**専用の拡張ツール**を追加して親子タスク管理を実現するのがよいでしょう。実際、コミュニティではEchoingVesper氏の*MCP Task Orchestrator*のように、AIエージェント用のタスク管理サーバーを実装してGoose等から使えるようにした例もあります。つまり、Gooseから見て「サブタスクを実行するための仮想的なツール」を提供し、その裏で新たなGooseインスタンス（子エージェント）を起動して処理させ、結果だけを返すというアプローチです。Gooseはマルチプロセス実行や複数エージェントの同時稼働自体は標準機能では持ちませんが、拡張を通じてこうした**エージェントinエージェント**のオーケストレーションを組み込むことが可能です。

Goose-flow（既存実装）は、この課題に対して独自に工夫されたCLIツールでした。goose-flowは21種類ものモード（役割特化エージェント）を用意し、`orchestrator`モードを親とすることで**階層的なタスク実行（親子関係のタスクスタック）**を実現しようとしていました。具体的には、モデルの出力テキスト中に`new_task {...}`や`attempt_completion {...}`というコマンド形式の文字列を埋め込ませ、goose-flow側でそれをパースして新規子プロセスの起動や親タスクの再開を行っています。親タスクは子がある間は状態を「paused」にし、子タスク完了時に`attempt_completion`で親に結果を渡して再開、といった**LIFOスタック型の制御**を取っていました。発想自体はRoo Codeのブーメラン型オーケストレーションに近く、Gooseをラップする形で並行実行やタスク階層を実現していたのです。

しかし現在のgoose-flow実装は安定性や汎用性の面で課題があり、「Roo Code的アプローチではうまくいかなかった」とのことです。課題の一因は、**LLMからの出力テキストを正確に解析して制御信号を読み取る**という方式にあります。この方法だと、モデルが少しでもフォーマットを崩すとパーサーが意図を読み取れない恐れがありますし、プロンプトで厳密に出力を強制する手間も大きいです。Claude CodeのようにAnthropicが用意した公式ツール呼び出し（構造化JSONによるツール実行）の仕組みがない環境では、テキスト解析ベースの手法には限界がありました。そこで、**よりClaude Code的なアプローチ**、すなわち**Goose本来のツール拡張機構を活用した正規のタスク実行インターフェース**を用いることで、より堅牢かつシンプルにオーケストレーションを実現したいと考えられます。

## Claude Code流アプローチでのGoose-flow再設計

理想的な設計としては、**Claude CodeのTaskツールに相当する機能をGooseの拡張ツールとして実装**し、goose-flow（またはそれに代わる新システム）に組み込むことを提案します。具体的には、Goose用のカスタムMCPサーバー（またはローカル拡張）として「`Task`ツール」を作成します。このツールはパラメータとして「`description`（サブタスクの説明）」と「`prompt`（サブタスク用の具体的指示）」を受け取り、**その場で新しいGooseエージェントプロセスを立ち上げて**指定のサブタスクを実行します。そして子エージェントの実行結果（回答や生成物）を**親エージェントへのツール呼び出し結果として返す**のです。親のGooseエージェントから見ると、まるで外部APIかデータベース検索でも呼んだかのように、単にTaskツールを使って結果を取得した形になります。このとき子エージェントには**必要最小限のコンテキスト**だけを与えるのがポイントです。具体的には親から渡された`prompt`（サブタスクの具体指示）に加え、必要なら現在のファイルや対象範囲に関する情報のみを提供し、親の大量の履歴や他の余計な情報は与えません。そうすることで**子は狭いコンテキストで効率よく作業でき**、子の会話履歴がどれだけ膨らんでも親には凝縮された結果（要点）だけが返ってくるため、トークン使用量を大幅に抑制できます。

**チェックリスト（進捗管理）**の扱いも、この再設計における重要な要素です。Claude Code同様に、親エージェント（Goose orchestrator）に**事前プランニング**をさせるプロンプトを与え、Todoリスト的なものを作らせます。その実装方法はいくつか考えられます。単純には、親エージェントに「まずステップ一覧を箇条書きして」と指示し、その出力をユーザーに見せるだけでも良いでしょう。しかしGooseは拡張次第でファイル書き込みもできますから、例えば**専用の「Progress.md」ファイルにTodoを記録するツール**を作り、親エージェントが適宜それを更新するようにしても良いでしょう。GooseのFilesystem拡張やMemory拡張を利用して、親が「Step 1: ～ (Done/Not Done)」といった状態を書き込み・読み出しする形で実現すれば、UI上でユーザーが進捗を確認することも可能になります。いずれにせよ、「タスクを**開始する前に全体像を俯瞰して計画を立てる**」「各ステップ終了後に**計画を見直して必要なら修正する**」というClaude Codeのオーケストレーター戦略を組み込むことが重要です。これにより、親エージェントは常にゴールまでの道筋を意識しながら柔軟に対応できるようになります。

新しいGoose-flowでは、**親子関係の制御はすべて内部のタスク管理ロジックで処理**され、モデルの生テキスト解析に頼る必要が無くなります。親エージェントが子タスクを必要と判断した際は、単に`Task`ツールを呼ぶだけです（ツール呼び出しそのものはJSONで構造化されるため信頼性が高い）。親はツールの実行が終わるまで待機し、返ってきた結果を受け取ったら会話を続行します。この待機期間中、親タスクの状態は**自動的に「一時停止中」**になりますが、ユーザーから見るとツール実行中の状態なので不自然ではありません。並列タスクの実行については、**Goose側で擬似的に並列化する**ことも可能です。例えば拡張の実装で、複数のサブタスクを配列として受け取った場合に内部でスレッドやプロセスを並行起動し、すべて完了してから結果リストを返すようにすることも考えられます。モデル側のプロンプトでも「複数のTaskツールを同時に呼び出してよい」旨を教示すれば、Claudeのように**一度に複数のツール呼び出しを提案させる**ことも理論上は可能です。Goose純正の機能ではツール実行は順次ですが、拡張サーバー内で非同期処理すれば疑似的に並列を再現できます。ただ、設計の初期段階では無理に高度な並列化をせず、まず**1ステップ内は逐次的に子タスクを実行**しても十分でしょう。各ステップ自体を小さく区切れば並列化しなくても大きな遅延は避けられますし、処理の追跡もしやすく安全です。将来的に拡張側で安定した並行処理が可能と分かれば、モデルに複数Taskを一括投入させる方向に拡張すれば良いでしょう。

最後に、**Claude Code流アプローチのメリット**を整理します。第一に、MCP拡張として実装することで**堅牢性が大幅に向上**します。ツール呼び出しは構造化データで行われるため、従来のようにモデル出力の文字列をパターンマッチする必要がなく、フォーマット揺れによる失敗が起きにくくなります。第二に、**コンテキスト管理が効率化**します。親→子への引き継ぎ情報を最小限に絞ることで、各エージェントが自分の役割に専念でき、不要な知識でコンテキストウィンドウを圧迫しません。第三に、**開発のシンプルさと拡張性**です。Goose-flow既存実装では複雑なプロセス管理・ログ監視・パーサーが必要でしたが、新設計ではGoose/LLM側のプロンプト設計と拡張ツールの機能実装に注力できます。Goose自体のアップデートでMCPやレシピ機能が拡張された場合でも、標準的な拡張として実装しておけば互換性を保ちやすいでしょう。何より、Anthropic Claude Codeや他社エージェントで実証された手法（タスク分割＋チェックリスト＋MCP）のエッセンスを取り入れることで、**より少ないコストで高度な自動化を実現できる**と期待できます。現状のgoose-flowにとらわれず、「理想的なオーケストレーター」をゼロベースで設計することで、Gooseを使った新しい開発支援フローが実現できるでしょう。

**Sources:**

* Claude CodeにおけるTaskツールとMCPサーバー構成の解説
* Claude Code Orchestratorプロンプトの手順例（逐次ステップ＋並列サブタスク）
* Taskツールによる親子コンテキスト分離と結果サマリ化の効果
* Todoリスト（チェックリスト）活用の有用性
* Goose-flowの既存アプローチと課題（親子タスク、スタック管理、ツール文字列解析）
* EchoingVesperのMCP Task Orchestrator概要（複数役割によるタスク分解例）
* Gooseの設計思想とMCP拡張によるワークフロー自動化
